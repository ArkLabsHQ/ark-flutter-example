// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'ark_api.freezed.dart';

Future<bool> walletExists({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiWalletExists(dataDir: dataDir);

Future<String> setupNewWallet({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiSetupNewWallet(dataDir: dataDir);

Future<String> loadExistingWallet({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiLoadExistingWallet(dataDir: dataDir);

Future<String> restoreWallet({required String nsec, required String dataDir}) =>
    RustLib.instance.api
        .crateApiArkApiRestoreWallet(nsec: nsec, dataDir: dataDir);

Future<Balance> balance() => RustLib.instance.api.crateApiArkApiBalance();

Future<Addresses> address() => RustLib.instance.api.crateApiArkApiAddress();

Future<List<Transaction>> txHistory() =>
    RustLib.instance.api.crateApiArkApiTxHistory();

Future<String> send({required String address, required BigInt amountSats}) =>
    RustLib.instance.api
        .crateApiArkApiSend(address: address, amountSats: amountSats);

Future<void> settle() => RustLib.instance.api.crateApiArkApiSettle();

Future<String> nsec({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiNsec(dataDir: dataDir);

Future<void> resetWallet({required String dataDir}) =>
    RustLib.instance.api.crateApiArkApiResetWallet(dataDir: dataDir);

Future<Info> information() => RustLib.instance.api.crateApiArkApiInformation();

class Addresses {
  final String boarding;
  final String offchain;
  final String bip21;

  const Addresses({
    required this.boarding,
    required this.offchain,
    required this.bip21,
  });

  @override
  int get hashCode => boarding.hashCode ^ offchain.hashCode ^ bip21.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Addresses &&
          runtimeType == other.runtimeType &&
          boarding == other.boarding &&
          offchain == other.offchain &&
          bip21 == other.bip21;
}

class Balance {
  final OffchainBalance offchain;

  const Balance({
    required this.offchain,
  });

  @override
  int get hashCode => offchain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balance &&
          runtimeType == other.runtimeType &&
          offchain == other.offchain;
}

class Info {
  final String serverPk;
  final String network;
  final String esplora;
  final String serverUrl;

  const Info({
    required this.serverPk,
    required this.network,
    required this.esplora,
    required this.serverUrl,
  });

  @override
  int get hashCode =>
      serverPk.hashCode ^
      network.hashCode ^
      esplora.hashCode ^
      serverUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Info &&
          runtimeType == other.runtimeType &&
          serverPk == other.serverPk &&
          network == other.network &&
          esplora == other.esplora &&
          serverUrl == other.serverUrl;
}

class OffchainBalance {
  final BigInt pendingSats;
  final BigInt confirmedSats;
  final BigInt totalSats;

  const OffchainBalance({
    required this.pendingSats,
    required this.confirmedSats,
    required this.totalSats,
  });

  @override
  int get hashCode =>
      pendingSats.hashCode ^ confirmedSats.hashCode ^ totalSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OffchainBalance &&
          runtimeType == other.runtimeType &&
          pendingSats == other.pendingSats &&
          confirmedSats == other.confirmedSats &&
          totalSats == other.totalSats;
}

@freezed
sealed class Transaction with _$Transaction {
  const Transaction._();

  const factory Transaction.boarding({
    required String txid,
    required BigInt amountSats,
    PlatformInt64? confirmedAt,
  }) = Transaction_Boarding;
  const factory Transaction.round({
    required String txid,
    required PlatformInt64 amountSats,
    required PlatformInt64 createdAt,
  }) = Transaction_Round;
  const factory Transaction.redeem({
    required String txid,
    required PlatformInt64 amountSats,
    required bool isSettled,
    required PlatformInt64 createdAt,
  }) = Transaction_Redeem;
}
